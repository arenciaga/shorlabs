FROM public.ecr.aws/docker/library/node:20-slim

# Add Lambda Web Adapter
COPY --from=public.ecr.aws/awsguru/aws-lambda-adapter:0.9.1 /lambda-adapter /opt/extensions/lambda-adapter

# Target app directory (. for standalone, subdir for monorepo)
ARG APP_DIR=.
ENV APP_DIR=$APP_DIR

# User environment variables (injected at deploy time)
{{USER_ARGS}}

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl \
    ca-certificates \
    unzip \
    && rm -rf /var/lib/apt/lists/*

# Enable corepack for pnpm/yarn
RUN corepack enable 2>/dev/null || true

# Copy entire repo (always from root for workspace resolution)
COPY . .

# ============================================================
# Phase 1: Detect package manager and install all dependencies
# ============================================================
# Industry standard: Always install from repo root so workspace
# symlinks/hoisting resolves correctly (Vercel, Railway, Render
# all do this). This works for both monorepos and standalone.
# ============================================================
RUN set -e && \
    echo "=== Detecting package manager ===" && \
    PM="npm" && \
    if [ -f "bun.lockb" ] || [ -f "bun.lock" ]; then \
        PM="bun" && \
        echo "Bun detected" && \
        curl -fsSL https://bun.sh/install | bash && \
        export PATH="$HOME/.bun/bin:$PATH" && \
        $HOME/.bun/bin/bun install; \
    elif [ -f "pnpm-lock.yaml" ]; then \
        PM="pnpm" && \
        echo "pnpm detected" && \
        corepack prepare pnpm@latest --activate && \
        pnpm install --no-frozen-lockfile; \
    elif [ -f "yarn.lock" ]; then \
        PM="yarn" && \
        echo "Yarn detected" && \
        corepack prepare yarn@stable --activate && \
        yarn install; \
    else \
        echo "npm detected" && \
        npm ci 2>/dev/null || npm install; \
    fi && \
    echo "PM=$PM" > /tmp/pm_env && \
    echo "=== Dependencies installed ==="

# ============================================================
# Phase 2: Build the target app
# ============================================================
# Industry standard: Build from root, targeting the specific
# workspace package. For standalone projects (APP_DIR=.),
# just run build in place. For monorepos, use the package
# manager's workspace-aware build commands so dependencies
# are built first in topological order.
# ============================================================
RUN set -e && \
    . /tmp/pm_env && \
    if [ -f "$HOME/.bun/bin/bun" ]; then export PATH="$HOME/.bun/bin:$PATH"; fi && \
    echo "=== Building project (APP_DIR=$APP_DIR) ===" && \
    if [ "$APP_DIR" = "." ]; then \
        echo "Standalone project" && \
        HAS_BUILD=$(node -e "console.log(require('./package.json').scripts?.build ? 'yes' : 'no')" 2>/dev/null || echo "no") && \
        if [ "$HAS_BUILD" = "yes" ]; then \
            echo "Running build..." && \
            case $PM in \
                bun) bun run build ;; \
                pnpm) pnpm run build ;; \
                yarn) yarn build ;; \
                npm) npm run build ;; \
            esac; \
        fi; \
    else \
        echo "Monorepo: building workspace at $APP_DIR" && \
        APP_NAME=$(node -e "console.log(require('./$APP_DIR/package.json').name || '')" 2>/dev/null || echo "") && \
        echo "Workspace package name: $APP_NAME" && \
        if [ -n "$APP_NAME" ]; then \
            echo "Building $APP_NAME and its dependencies..." && \
            case $PM in \
                bun) bun run --filter "$APP_NAME" build 2>/dev/null || (cd "$APP_DIR" && bun run build) ;; \
                pnpm) pnpm --filter "$APP_NAME"... run build 2>/dev/null || (cd "$APP_DIR" && pnpm run build) ;; \
                yarn) yarn workspaces foreach --from "$APP_NAME" --topological run build 2>/dev/null || (cd "$APP_DIR" && yarn build) ;; \
                npm) npm run build --workspace="$APP_NAME" --if-present 2>/dev/null || (cd "$APP_DIR" && npm run build) ;; \
            esac; \
        else \
            echo "No package name found, building directly in $APP_DIR" && \
            cd "$APP_DIR" && \
            HAS_BUILD=$(node -e "console.log(require('./package.json').scripts?.build ? 'yes' : 'no')" 2>/dev/null || echo "no") && \
            if [ "$HAS_BUILD" = "yes" ]; then \
                case $PM in \
                    bun) bun run build ;; \
                    pnpm) pnpm run build ;; \
                    yarn) yarn build ;; \
                    npm) npm run build ;; \
                esac; \
            fi; \
        fi; \
    fi && \
    echo "=== Build complete ==="

# Add bun to PATH if installed (persists across layers and at runtime)
ENV PATH="/root/.bun/bin:$PATH"

# Install serve for Vite/CRA static builds (dist/ or build/)
RUN npm install -g serve

# ============================================================
# Phase 2.5: Copy Next.js standalone static assets at build time
# ============================================================
# Lambda has a read-only filesystem, so this MUST happen during
# the Docker build, not at runtime. For monorepos, server.js is
# nested (e.g. .next/standalone/apps/frontend/server.js) and
# static/public must be copied NEXT TO server.js, not at the
# standalone root. See: https://github.com/vercel/next.js/issues/78446
# ============================================================
RUN set -e && \
    cd /app/$APP_DIR && \
    STANDALONE_SERVER=$(find .next/standalone -path "*/node_modules" -prune -o -name "server.js" -type f -print 2>/dev/null | head -1) && \
    if [ -n "$STANDALONE_SERVER" ]; then \
        SERVER_DIR=$(cd "$(dirname "$STANDALONE_SERVER")" && pwd) && \
        echo "=== Copying Next.js standalone assets ===" && \
        echo "server.js location: $SERVER_DIR" && \
        if [ -d ".next/static" ]; then \
            mkdir -p "$SERVER_DIR/.next" && \
            cp -r .next/static "$SERVER_DIR/.next/" && \
            echo "Copied .next/static to $SERVER_DIR/.next/static"; \
        fi && \
        if [ -d "public" ]; then \
            cp -r public "$SERVER_DIR/" && \
            echo "Copied public to $SERVER_DIR/public"; \
        fi && \
        echo "=== Standalone assets ready ==="; \
    else \
        echo "=== No Next.js standalone build detected, skipping ==="; \
    fi

# Default port (Lambda Web Adapter expects 8080)
ENV PORT=8080
ENV HOSTNAME=0.0.0.0
ENV NODE_ENV=production
ENV AWS_LWA_INVOKE_MODE=response_stream

# ============================================================
# Phase 3: Start script
# ============================================================
# Industry standard: cd into the app directory and run the
# start script from there. For standalone (APP_DIR=.), this
# is just /app. For monorepos, it's /app/<workspace-dir>.
# ============================================================
RUN echo '#!/bin/sh\n\
set -e\n\
\n\
# Load package manager\n\
if [ -f "/tmp/pm_env" ]; then\n\
    . /tmp/pm_env\n\
fi\n\
\n\
# Add bun to path if installed\n\
if [ -f "$HOME/.bun/bin/bun" ]; then\n\
    export PATH="$HOME/.bun/bin:$PATH"\n\
fi\n\
\n\
# Navigate to the app directory\n\
cd /app/$APP_DIR\n\
\n\
# Next.js standalone: run node server.js (avoids Bun + Lambda Runtime.ExitError)\n\
# In monorepos server.js can be at .next/standalone/apps/<app>/server.js (see Next.js #78446)\n\
STANDALONE_SERVER=$(find .next/standalone -path "*/node_modules" -prune -o -name "server.js" -type f -print 2>/dev/null | head -1)\n\
if [ -n "$STANDALONE_SERVER" ]; then\n\
    STANDALONE_ABS=$(cd "$(dirname "$STANDALONE_SERVER")" && pwd)\n\
    echo "Starting: Next.js standalone (node server.js) from $STANDALONE_ABS"\n\
    cd "$STANDALONE_ABS" && exec node server.js\n\
fi\n\
\n\
START_CMD=$(node -e "console.log(require('"'"'./package.json'"'"').scripts?.start || '"'"''"'"')" 2>/dev/null || echo "")\n\
\n\
if [ -n "$START_CMD" ]; then\n\
    echo "Starting: $START_CMD"\n\
    # Next.js: always run with Node in Lambda (Bun can cause Runtime.ExitError)\n\
    if [ "$START_CMD" = "next start" ]; then\n\
        exec node ./node_modules/next/dist/bin/next start\n\
    fi\n\
    case $PM in\n\
        bun) exec bun run start ;;\n\
        pnpm) exec pnpm run start ;;\n\
        yarn) exec yarn start ;;\n\
        npm) exec npm run start ;;\n\
    esac\n\
else\n\
    # Vite / Create React App: serve static build if dist/ or build/ exists (no index.js)\n\
    if [ -d "dist" ]; then\n\
        echo "Starting: serve (Vite static build)"\n\
        exec serve -s dist -l "$PORT"\n\
    fi\n\
    if [ -d "build" ]; then\n\
        echo "Starting: serve (CRA static build)"\n\
        exec serve -s build -l "$PORT"\n\
    fi\n\
    MAIN=$(node -e "console.log(require('"'"'./package.json'"'"').main || '"'"'index.js'"'"')" 2>/dev/null || echo "index.js")\n\
    echo "Starting: node $MAIN"\n\
    exec node "$MAIN"\n\
fi\n\
' > /start.sh && chmod +x /start.sh

WORKDIR /app

CMD ["/start.sh"]
